
==================== FINAL INTERFACE ====================
2018-12-23 19:39:17.9493515 UTC

interface main:Main 8044
  interface hash: 4b2cc34097a2171479bdc21b4ae04084
  ABI hash: 726c3546fb668d94bd16a727d0120236
  export-list hash: dc87f15f0c3427777eb5c2e6fcb6a41f
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: eeedd86d50827151214d38cb982bd914
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.==>
  Main.and
  Main.emptyAllocator
  Main.emptyLState
  Main.eq
  Main.for
  Main.format
  Main.main
  Main.neq
  Main.not
  Main.nub
  Main.or
  Main.pruneSol
  Main.sol
  Main.test
  Main.toSol
  Main.total
  Main.|-
  Main.|||
  Main.Option{Main.A Main.B Main.C Main.D}
  Main.Term{Main.Sol Main.Var}
module dependencies: Rcheck.BrMonad Rcheck.Logic Rcheck.Solver
package dependencies: array-0.5.2.0 base-4.11.1.0*
                      containers-0.5.11.0 deepseq-1.4.3.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Set.Internal
import  -/  base-4.11.1.0:Control.Monad 60c7bc648329161549cea9b9658c9b81
import  -/  base-4.11.1.0:Data.Foldable 6cf3e918f22d03c0870804f05cd183d1
import  -/  base-4.11.1.0:Data.List cb78ca5eace70fd310936fda86b3e611
import  -/  base-4.11.1.0:Data.OldList 3987872d5de68d40c22cd1c30825ad08
import  -/  base-4.11.1.0:Data.Traversable 6506d675f7e45edd6c22add801f79ba8
import  -/  base-4.11.1.0:Data.Tuple bfd15ca14ee9b1b9cd782c618946afb4
import  -/  base-4.11.1.0:GHC.Base b7dd14d8fe8d606dde5678ea6b0575e9
import  -/  base-4.11.1.0:GHC.Enum e4ba78b4713760aa26fb70e6c50823d5
import  -/  base-4.11.1.0:GHC.Err 97cd376c529926d7dcbd3f06020fe0fc
import  -/  base-4.11.1.0:GHC.List 95910b50fba2204d1a3364fe070ebf2b
import  -/  base-4.11.1.0:GHC.Num 5de8df0185e7e8d8ec29b3c61e2c8606
import  -/  base-4.11.1.0:GHC.Show 6211aec7cccd267a5ee999e4414d7b90
import  -/  base-4.11.1.0:Prelude aca391812f777207b15d62bb5b9feb63
import  -/  base-4.11.1.0:System.IO 4c8fe011020182bbb838fae9b78bbe23
import  -/  containers-0.5.11.0:Data.Map 1fa9f25d51fe9f60b440e141f6d7bf14
import  -/  containers-0.5.11.0:Data.Map.Internal a2314ee57e16ff1fe3af08500b455e81
import  -/  containers-0.5.11.0:Data.Set eb0fbc743d474b13246bc4dbf4a83977
import  -/  containers-0.5.11.0:Data.Set.Internal 0672c19b08cec68fbd0f1408b7c182d5
import  -/  ghc-prim-0.5.2.0:GHC.Classes f7d67fd97d5a20e9252c9597d1aa387b
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  Rcheck.BrMonad 8e90abdc1a4a799c3a6fcf1c55375145
  exports: 8cc780bb56fddbf32ab5dabaae26a071
  Br 96a605991104d8254cd6ca63879be779
  getBy 8cc8ee9b2e45890363f9e380bfb586b1
  reset 3487accaef8a100bfa458659abd062fa
  runBr 96a605991104d8254cd6ca63879be779
  union 011d91dba996272ebd60937b54bb4fb4
import  -/  Rcheck.Logic 86dd86fec523e20b52a2ebbb35b0585e
  exports: 41fdbb7f956cf64407209a9aafbbac9e
  And b0422147f847c6c7803375ad41c496e7
  Cond 96108f28e7e93012fdcdc5a09604f80b
  Imply 94f90904aa6e772cd6e7e24051177587
  Not b6c1dff7bcc554dd82998c1f3a854d26
  Or 2f7e6422d53061d3cac1a1b19bf451c3
  Pred 36d161cd61b723cfa093ac11754af713
  Unify 4fa14bf6138851b6903059747d38bc8e
  require b03477c4a21ed3dc9773fc77ff1f5cf3
  solve ca4f770c17d948ba24ea5da9c789b303
  solveNeg 550f91462ab2eab78b49d061cbfc7c49
  solvePred 91548779cae33d4a4a1176cfec9bf7ac
import  -/  Rcheck.Solver 9a33f437f6e2bd1987a853b0bb3e8e89
  exports: 107901bb74093ade186dca8b27ec155f
  Allocator 55278aa278ad8a29c9cc6803f47b1371
  Complement 13e9fbc8f02c972f9cce387c51539b85
  EnumSet 8e657ed5042ab16c7bdb42ecf64e430e
  LState 1d5f40165d21ad7734f6cf1f80cfb5e5
  LState 23e909c1edeeb7c95c204c45b9155ab5
  Reference f6e9771570b003b0676679c95675aa63
  Unify cfbea0a234bb5ac855cd1c2fd4c33c0f
  allocator 23e909c1edeeb7c95c204c45b9155ab5
  complement 9d3242501349e221962ffec79e392729
  load 43091774344601ff0908ed65db7e998d
  storage c95b5130bf81f25b674b80d45578e04b
  store f437cd83bf2e51f217979b836c33b3be
  unify baa765c69095abc6e53ef47327a9aaf7
  update 921ebfb3dc578b7d8f260d7d0f4a4d34
fixities infixr 4 ==>, infixr 6 and, infixr 7 eq, infixr 7 neq,
         infixr 5 or, infixr 6 |-, infixr 3 |||
bb2123bad4e2d9c530a12b7e82302052
  $fComplementTerm :: Rcheck.Solver.Complement Main.Term
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Term Main.$fUnifyTerm Main.$fComplementTerm_$ccomplement -}
bb2123bad4e2d9c530a12b7e82302052
  $fComplementTerm_$ccomplement ::
    Rcheck.Solver.Addr
    -> Rcheck.Solver.Addr
    -> Rcheck.BrMonad.Br (Rcheck.Solver.LState Main.Term) ()
  {- Arity: 2, Strictness: <L,U><L,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Rcheck.Solver.Addr) (w1 :: Rcheck.Solver.Addr) ->
                 case Main.$w$ccomplement w w1 of ww { Unit# ww1 ->
                 Rcheck.BrMonad.Br @ (Rcheck.Solver.LState Main.Term) @ () ww1 }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption :: GHC.Enum.Enum Main.Option
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Option
                  Main.$fEnumOption_$csucc
                  Main.$fEnumOption_$cpred
                  Main.$fEnumOption_$ctoEnum
                  Main.$fEnumOption_$cfromEnum
                  Main.$fEnumOption_$cenumFrom
                  Main.$fEnumOption_$cenumFromThen
                  Main.$fEnumOption_$cenumFromTo
                  Main.$fEnumOption_$cenumFromThenTo -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption1 :: [Main.Option]
  {- Unfolding: (Main.$fEnumOption_go4 3#) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption2 :: [Main.Option]
  {- Unfolding: (Main.$fEnumOption_go4 2#) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption3 :: [Main.Option]
  {- Unfolding: (Main.$fEnumOption_go4 1#) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption4 :: [Main.Option]
  {- Unfolding: (Main.$fEnumOption_go4 0#) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption5 :: Main.Option
  {- Strictness: x -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption6 :: Main.Option
  {- Strictness: x -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_$cenumFrom :: Main.Option -> [Main.Option]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Main.Option) ->
                 case a of wild {
                   Main.A -> Main.$fEnumOption4
                   Main.B -> Main.$fEnumOption3
                   Main.C -> Main.$fEnumOption2
                   Main.D -> Main.$fEnumOption1 }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_$cenumFromThen ::
    Main.Option -> Main.Option -> [Main.Option]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_$cenumFromThenTo ::
    Main.Option -> Main.Option -> Main.Option -> [Main.Option]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_$cenumFromTo ::
    Main.Option -> Main.Option -> [Main.Option]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Main.Option) (y :: Main.Option) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Main.Option]
                     <join 1> {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Main.A
                       -> case GHC.Prim.># x1 0# of lwild {
                            DEFAULT -> Main.$fEnumOption_go3 x1
                            1# -> GHC.Types.[] @ Main.Option }
                       Main.B
                       -> case GHC.Prim.># x1 1# of lwild {
                            DEFAULT -> Main.$fEnumOption_go2 x1
                            1# -> GHC.Types.[] @ Main.Option }
                       Main.C
                       -> case GHC.Prim.># x1 2# of lwild {
                            DEFAULT -> Main.$fEnumOption_go1 x1
                            1# -> GHC.Types.[] @ Main.Option }
                       Main.D
                       -> case GHC.Prim.># x1 3# of lwild {
                            DEFAULT -> Main.$fEnumOption_go x1
                            1# -> GHC.Types.[] @ Main.Option } }
                 } in
                 case x of wild {
                   Main.A -> $j 0#
                   Main.B -> $j 1#
                   Main.C -> $j 2#
                   Main.D -> $j 3# }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_$cfromEnum :: Main.Option -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Main.Option) ->
                 case a of wild {
                   Main.A -> GHC.Types.I# 0#
                   Main.B -> GHC.Types.I# 1#
                   Main.C -> GHC.Types.I# 2#
                   Main.D -> GHC.Types.I# 3# }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_$cpred :: Main.Option -> Main.Option
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Main.Option) ->
                 case a of wild {
                   Main.A -> Main.$fEnumOption5
                   Main.B -> Main.A
                   Main.C -> Main.B
                   Main.D -> Main.C }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_$csucc :: Main.Option -> Main.Option
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Main.Option) ->
                 case a of wild {
                   Main.A -> Main.B
                   Main.B -> Main.C
                   Main.C -> Main.D
                   Main.D -> Main.$fEnumOption6 }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_$ctoEnum :: GHC.Types.Int -> Main.Option
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 -> Main.$w$ctoEnum ww1 }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_go :: GHC.Prim.Int# -> [Main.Option]
  {- Arity: 1, Strictness: <L,U>m2 -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_go1 :: GHC.Prim.Int# -> [Main.Option]
  {- Arity: 1, Strictness: <L,U>m2 -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_go2 :: GHC.Prim.Int# -> [Main.Option]
  {- Arity: 1, Strictness: <L,U>m2 -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_go3 :: GHC.Prim.Int# -> [Main.Option]
  {- Arity: 1, Strictness: <L,U>m2 -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEnumOption_go4 :: GHC.Prim.Int# -> [Main.Option]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2 -}
bb2123bad4e2d9c530a12b7e82302052
  $fEnumSetTerm :: Rcheck.Solver.EnumSet Main.Term
  DFunId
  {- Strictness: m, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Main.$fEnumSetTerm_$ctoEnumerable
                  `cast`
                (Sym (Rcheck.Solver.N:EnumSet[0] <Main.Term>_N)) -}
bb2123bad4e2d9c530a12b7e82302052
  $fEnumSetTerm1 ::
    Rcheck.Solver.LState Main.Term
    -> [((), Rcheck.Solver.LState Main.Term)]
  {- Arity: 1, Strictness: <L,U(U(U,U),U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Rcheck.Solver.LState Main.Term) ->
                 Main.$fEnumSetTerm_go
                   (GHC.Types.:
                      @ (Data.Map.Internal.Map GHC.Types.Int Main.Term,
                         Rcheck.Solver.LState Main.Term)
                      (case s1 of wild { Rcheck.Solver.LState ds1 ds2 ds3 ->
                       case ds1 of wild1 { Rcheck.Solver.Allocator ds4 ds5 -> ds4 } },
                       s1)
                      (GHC.Types.[]
                         @ (Data.Map.Internal.Map GHC.Types.Int Main.Term,
                            Rcheck.Solver.LState Main.Term)))) -}
bb2123bad4e2d9c530a12b7e82302052
  $fEnumSetTerm_$ctoEnumerable ::
    Rcheck.BrMonad.Br (Rcheck.Solver.LState Main.Term) ()
  {- Strictness: m,
     Unfolding: (Rcheck.BrMonad.Br
                   @ (Rcheck.Solver.LState Main.Term)
                   @ ()
                   Main.$fEnumSetTerm1) -}
bb2123bad4e2d9c530a12b7e82302052
  $fEnumSetTerm_go ::
    [(Data.Map.Internal.Map GHC.Types.Int Main.Term,
      Rcheck.Solver.LState Main.Term)]
    -> [((), Rcheck.Solver.LState Main.Term)]
  {- Arity: 1, Strictness: <S,1*U> -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEqOption :: GHC.Classes.Eq Main.Option
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Option Main.$fEqOption_$c== Main.$fEqOption_$c/= -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEqOption_$c/= :: Main.Option -> Main.Option -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Main.Option) (y :: Main.Option) ->
                 case x of wild {
                   Main.A
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True Main.A -> GHC.Types.False }
                   Main.B
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True Main.B -> GHC.Types.False }
                   Main.C
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True Main.C -> GHC.Types.False }
                   Main.D
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True Main.D -> GHC.Types.False } }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fEqOption_$c== :: Main.Option -> Main.Option -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Main.Option) (ds1 :: Main.Option) ->
                 case ds of wild {
                   Main.A
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.A -> GHC.Types.True }
                   Main.B
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.B -> GHC.Types.True }
                   Main.C
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.C -> GHC.Types.True }
                   Main.D
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.D -> GHC.Types.True } }) -}
bb2123bad4e2d9c530a12b7e82302052
  $fEqTerm :: GHC.Classes.Eq Main.Term
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Term Main.$fEqTerm_$c== Main.$fEqTerm_$c/= -}
bb2123bad4e2d9c530a12b7e82302052
  $fEqTerm_$c/= :: Main.Term -> Main.Term -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Main.Term) (y :: Main.Term) ->
                 case Main.$fEqTerm_$c== x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
bb2123bad4e2d9c530a12b7e82302052
  $fEqTerm_$c== :: Main.Term -> Main.Term -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Main.Term) (ds1 :: Main.Term) ->
                 case ds of wild {
                   Main.Var a1
                   -> case ds1 of wild1 {
                        Main.Var b1 -> GHC.Classes.eqInt a1 b1
                        Main.Sol ipv -> GHC.Types.False }
                   Main.Sol a1
                   -> case ds1 of wild1 {
                        Main.Var ipv -> GHC.Types.False
                        Main.Sol b1
                        -> Data.Set.Internal.$fEqSet_$c==
                             @ Main.Option
                             Main.$fEqOption
                             a1
                             b1 } }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fOrdOption :: GHC.Classes.Ord Main.Option
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Option
                  Main.$fEqOption
                  Main.$fOrdOption_$ccompare
                  Main.$fOrdOption_$c<
                  Main.$fOrdOption_$c<=
                  Main.$fOrdOption_$c>
                  Main.$fOrdOption_$c>=
                  Main.$fOrdOption_$cmax
                  Main.$fOrdOption_$cmin -}
3b7dbedc3c67552275f00ba17a40f48c
  $fOrdOption_$c< :: Main.Option -> Main.Option -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Main.Option) (b :: Main.Option) ->
                 case a of wild {
                   Main.A
                   -> case b of wild1 {
                        Main.A -> GHC.Types.False
                        Main.B -> GHC.Types.True
                        Main.C -> GHC.Types.True
                        Main.D -> GHC.Types.True }
                   Main.B
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Main.C -> GHC.Types.True
                        Main.D -> GHC.Types.True }
                   Main.C
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False Main.D -> GHC.Types.True }
                   Main.D -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fOrdOption_$c<= :: Main.Option -> Main.Option -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Main.Option) (b :: Main.Option) ->
                 case b of wild {
                   Main.A
                   -> case a of wild1 {
                        Main.A -> GHC.Types.True
                        Main.B -> GHC.Types.False
                        Main.C -> GHC.Types.False
                        Main.D -> GHC.Types.False }
                   Main.B
                   -> case a of wild1 {
                        DEFAULT -> GHC.Types.True
                        Main.C -> GHC.Types.False
                        Main.D -> GHC.Types.False }
                   Main.C
                   -> case a of wild1 {
                        DEFAULT -> GHC.Types.True Main.D -> GHC.Types.False }
                   Main.D -> case a of wild1 { DEFAULT -> GHC.Types.True } }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fOrdOption_$c> :: Main.Option -> Main.Option -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ (a :: Main.Option) (b :: Main.Option) ->
                 Main.$fOrdOption_$c< b a) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fOrdOption_$c>= :: Main.Option -> Main.Option -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Main.Option) (b :: Main.Option) ->
                 case a of wild {
                   Main.A
                   -> case b of wild1 {
                        Main.A -> GHC.Types.True
                        Main.B -> GHC.Types.False
                        Main.C -> GHC.Types.False
                        Main.D -> GHC.Types.False }
                   Main.B
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Main.C -> GHC.Types.False
                        Main.D -> GHC.Types.False }
                   Main.C
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Main.D -> GHC.Types.False }
                   Main.D -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fOrdOption_$ccompare ::
    Main.Option -> Main.Option -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Main.Option) (b :: Main.Option) ->
                 case a of wild {
                   Main.A
                   -> case b of wild1 {
                        Main.A -> GHC.Types.EQ
                        Main.B -> GHC.Types.LT
                        Main.C -> GHC.Types.LT
                        Main.D -> GHC.Types.LT }
                   Main.B
                   -> case b of wild1 {
                        Main.A -> GHC.Types.GT
                        Main.B -> GHC.Types.EQ
                        Main.C -> GHC.Types.LT
                        Main.D -> GHC.Types.LT }
                   Main.C
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Main.C -> GHC.Types.EQ
                        Main.D -> GHC.Types.LT }
                   Main.D
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT Main.D -> GHC.Types.EQ } }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fOrdOption_$cmax :: Main.Option -> Main.Option -> Main.Option
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Main.Option) (y :: Main.Option) ->
                 case y of wild {
                   Main.A -> x
                   Main.B
                   -> case x of wild1 {
                        DEFAULT -> Main.B Main.C -> Main.C Main.D -> Main.D }
                   Main.C -> case x of wild1 { DEFAULT -> Main.C Main.D -> Main.D }
                   Main.D -> case x of wild1 { DEFAULT -> Main.D } }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fOrdOption_$cmin :: Main.Option -> Main.Option -> Main.Option
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Main.Option) (y :: Main.Option) ->
                 case y of wild {
                   Main.A -> case x of wild1 { DEFAULT -> Main.A }
                   Main.B
                   -> case x of wild1 {
                        DEFAULT -> wild1 Main.C -> Main.B Main.D -> Main.B }
                   Main.C -> case x of wild1 { DEFAULT -> wild1 Main.D -> Main.C }
                   Main.D -> x }) -}
bb2123bad4e2d9c530a12b7e82302052
  $fReferenceTerm :: Rcheck.Solver.Reference Main.Term
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Term Main.$fReferenceTerm_$cisRef Main.Var -}
bb2123bad4e2d9c530a12b7e82302052
  $fReferenceTerm_$cisRef ::
    Main.Term -> GHC.Base.Maybe Rcheck.Solver.Addr
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Term) ->
                 case ds of wild {
                   Main.Var addr -> GHC.Base.Just @ GHC.Types.Int addr
                   Main.Sol ipv -> GHC.Base.Nothing @ Rcheck.Solver.Addr }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fShowOption :: GHC.Show.Show Main.Option
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Option
                  Main.$fShowOption_$cshowsPrec
                  Main.$fShowOption_$cshow
                  Main.$fShowOption_$cshowList -}
d4ee523c18a182357e6f6faa6a89cf93
  $fShowOption1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowOption2) -}
454e7c0f775844ea8a758ee1d6b7ad7c
  $fShowOption2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("D"#) -}
73d0715da5b1d53a02514897890f9a3e
  $fShowOption3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowOption4) -}
c6f45c7cf6e9ca17e2b7567697a7de4b
  $fShowOption4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("C"#) -}
3c9c534d6150584dda9dd5fa2b043367
  $fShowOption5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowOption6) -}
d8639b219d62bfdea9c394d6c53e79e9
  $fShowOption6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("B"#) -}
3da184efa5acfa2ab7a7d6e45bcb517e
  $fShowOption7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowOption8) -}
0131fac67587fb2c2b5257b5b813d990
  $fShowOption8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("A"#) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fShowOption_$cshow :: Main.Option -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Main.Option) ->
                 case x of wild {
                   Main.A -> Main.$fShowOption7
                   Main.B -> Main.$fShowOption5
                   Main.C -> Main.$fShowOption3
                   Main.D -> Main.$fShowOption1 }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fShowOption_$cshowList :: [Main.Option] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.Option]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Main.Option Main.$w$cshowsPrec ls s) -}
3b7dbedc3c67552275f00ba17a40f48c
  $fShowOption_$cshowsPrec ::
    GHC.Types.Int -> Main.Option -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.Option)
                   (w2 :: GHC.Base.String) ->
                 Main.$w$cshowsPrec w1 w2) -}
bb2123bad4e2d9c530a12b7e82302052
  $fShowTerm :: GHC.Show.Show Main.Term
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Term
                  Main.$fShowTerm_$cshowsPrec
                  Main.$fShowTerm_$cshow
                  Main.$fShowTerm_$cshowList -}
bb2123bad4e2d9c530a12b7e82302052
  $fShowTerm1 :: Main.Term -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (w :: Main.Term) -> Main.$w$cshowsPrec1 0# w) -}
a799d93e5b28a67778c1ed41dd45b57a
  $fShowTerm2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowTerm3) -}
1621090fae70160bc4b1ce51be1d1bd1
  $fShowTerm3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Sol "#) -}
0bd729421c70dc25dc323a60b41febf0
  $fShowTerm4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Var "#) -}
07c1b70082677a6bb82241f44773bbb2
  $fShowTerm5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   GHC.Show.showList__4
                   Main.$fShowTerm_s) -}
bb2123bad4e2d9c530a12b7e82302052
  $fShowTerm_$cshow :: Main.Term -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Main.Term) ->
                 case x of wild {
                   Main.Var b1
                   -> GHC.CString.unpackAppendCString#
                        Main.$fShowTerm4
                        (case b1 of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt
                                11#
                                ww3
                                (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                   Main.Sol b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowTerm2
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.$fShow(,)4
                           (GHC.Base.++
                              @ GHC.Types.Char
                              Data.Set.Internal.$fShowSet1
                              (case Data.Set.Internal.$fDataSet_go
                                      @ Main.Option
                                      (GHC.Types.[] @ Main.Option)
                                      b1 of wild1 {
                                 [] -> Main.$fShowTerm5
                                 : x1 xs
                                 -> GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showList__3
                                      (Main.$w$cshowsPrec x1 (Main.$fShowTerm_showl xs)) }))) }) -}
bb2123bad4e2d9c530a12b7e82302052
  $fShowTerm_$cshowList :: [Main.Term] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.Term]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Main.Term Main.$fShowTerm1 ls s) -}
bb2123bad4e2d9c530a12b7e82302052
  $fShowTerm_$cshowsPrec ::
    GHC.Types.Int -> Main.Term -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Main.Term) ->
                 case w of ww { GHC.Types.I# ww1 -> Main.$w$cshowsPrec1 ww1 w1 }) -}
49fe2ddf90fc934e428d7e95d3207ac1
  $fShowTerm_s :: GHC.Base.String
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.$fShow(,)2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9533d2ff5636db1dbe1302879828be13
  $fShowTerm_showl :: [Main.Option] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>m2 -}
bb2123bad4e2d9c530a12b7e82302052
  $fUnifyTerm :: Rcheck.Solver.Unify Main.Term
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Term
                  Main.$fEqTerm
                  Main.$fReferenceTerm
                  Main.$fUnifyTerm_$cprune
                  Main.$fUnifyTerm_$cunify -}
bb2123bad4e2d9c530a12b7e82302052
  $fUnifyTerm_$cprune ::
    Main.Term
    -> Rcheck.BrMonad.Br
         (Rcheck.Solver.LState Main.Term) Rcheck.Solver.Addr
  {- Arity: 1, Strictness: <L,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Main.Term) ->
                 let {
                   w1 :: Rcheck.BrMonad.Br
                           (Rcheck.Solver.LState Main.Term)
                           (GHC.Types.Int, GHC.Base.Maybe (Data.Set.Internal.Set Main.Option))
                   = case Main.$wpruneSol w of ww { Unit# ww1 ->
                     Rcheck.BrMonad.Br
                       @ (Rcheck.Solver.LState Main.Term)
                       @ (GHC.Types.Int,
                          GHC.Base.Maybe (Data.Set.Internal.Set Main.Option))
                       ww1 }
                 } in
                 Rcheck.BrMonad.Br
                   @ (Rcheck.Solver.LState Main.Term)
                   @ Rcheck.Solver.Addr
                   (\ (s1 :: Rcheck.Solver.LState Main.Term) ->
                    case w1 of wild { Rcheck.BrMonad.Br ds ->
                    Main.$fUnifyTerm_go (ds s1) })) -}
bb2123bad4e2d9c530a12b7e82302052
  $fUnifyTerm_$cunify ::
    Main.Term
    -> Main.Term
    -> Rcheck.BrMonad.Br (Rcheck.Solver.LState Main.Term) ()
  {- Arity: 2, Strictness: <L,U><L,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Main.Term) (w1 :: Main.Term) ->
                 case Main.$w$cunify w w1 of ww { Unit# ww1 ->
                 Rcheck.BrMonad.Br @ (Rcheck.Solver.LState Main.Term) @ () ww1 }) -}
bb2123bad4e2d9c530a12b7e82302052
  $fUnifyTerm_go ::
    [((GHC.Types.Int,
       GHC.Base.Maybe (Data.Set.Internal.Set Main.Option)),
      Rcheck.Solver.LState Main.Term)]
    -> [(GHC.Types.Int, Rcheck.Solver.LState Main.Term)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
189539be66376c8928c0a7f39862cd58
  $salter_$sgo13 ::
    (GHC.Base.Maybe a1 -> GHC.Base.Maybe a1)
    -> Main.Option
    -> Data.Map.Internal.Map Main.Option a1
    -> Data.Map.Internal.Map Main.Option a1
  {- Arity: 3, Strictness: <C(S),1*C1(U)><S,1*U><S,1*U> -}
465b79376b4020b0e3d303c4b8723c18
  $sdelete_$sgo3 ::
    Main.Option
    -> Data.Set.Internal.Set Main.Option
    -> Data.Set.Internal.Set Main.Option
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
0824f1c291b436ab8d2dc2b3b8319947
  $sfromList :: [Main.Option] -> Data.Set.Internal.Set Main.Option
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Main.Option]) ->
                 case ds of wild {
                   [] -> Data.Set.Internal.Tip @ Main.Option
                   : x ds1
                   -> case ds1 of wild1 {
                        []
                        -> case x of dt { DEFAULT ->
                           Data.Set.Internal.Bin
                             @ Main.Option
                             1#
                             dt
                             (Data.Set.Internal.Tip @ Main.Option)
                             (Data.Set.Internal.Tip @ Main.Option) }
                        : ipv ipv1
                        -> case x of wild2 {
                             Main.A
                             -> case ipv of wild3 {
                                  Main.A -> Main.$sfromList_go4 Main.$sfromList4 wild1
                                  Main.B -> Main.$wgo3 1# Main.$sfromList4 wild1
                                  Main.C -> Main.$wgo3 1# Main.$sfromList4 wild1
                                  Main.D -> Main.$wgo3 1# Main.$sfromList4 wild1 }
                             Main.B
                             -> case ipv of wild3 {
                                  DEFAULT -> Main.$sfromList_go4 Main.$sfromList3 wild1
                                  Main.C -> Main.$wgo3 1# Main.$sfromList3 wild1
                                  Main.D -> Main.$wgo3 1# Main.$sfromList3 wild1 }
                             Main.C
                             -> case ipv of wild3 {
                                  DEFAULT -> Main.$sfromList_go4 Main.$sfromList2 wild1
                                  Main.D -> Main.$wgo3 1# Main.$sfromList2 wild1 }
                             Main.D
                             -> case ipv of wild3 { DEFAULT ->
                                Main.$sfromList_go4 Main.$sfromList1 wild1 } } } }) -}
2cbbca1ae5207ab73762eb56b882c641
  $sfromList1 :: Data.Set.Internal.Set Main.Option
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Data.Set.Internal.Bin
                   @ Main.Option
                   1#
                   Main.D
                   (Data.Set.Internal.Tip @ Main.Option)
                   (Data.Set.Internal.Tip @ Main.Option)) -}
011fbec0a718b9bb3f1bf514f729e44f
  $sfromList2 :: Data.Set.Internal.Set Main.Option
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Data.Set.Internal.Bin
                   @ Main.Option
                   1#
                   Main.C
                   (Data.Set.Internal.Tip @ Main.Option)
                   (Data.Set.Internal.Tip @ Main.Option)) -}
92f8a6128c47b3e0bd2e7fccc54b56ba
  $sfromList3 :: Data.Set.Internal.Set Main.Option
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Data.Set.Internal.Bin
                   @ Main.Option
                   1#
                   Main.B
                   (Data.Set.Internal.Tip @ Main.Option)
                   (Data.Set.Internal.Tip @ Main.Option)) -}
bb104e4a981aa64282e67c5fbdda1dbc
  $sfromList4 :: Data.Set.Internal.Set Main.Option
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Data.Set.Internal.Bin
                   @ Main.Option
                   1#
                   Main.A
                   (Data.Set.Internal.Tip @ Main.Option)
                   (Data.Set.Internal.Tip @ Main.Option)) -}
ea1e00d24db34d535d2d36d84760bfb8
  $sfromList_go4 ::
    Data.Set.Internal.Set Main.Option
    -> [Main.Option] -> Data.Set.Internal.Set Main.Option
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
54633750114670dca31449bb2e5321e0
  $sinsert_$sgo3 ::
    Main.Option
    -> Main.Option
    -> Data.Set.Internal.Set Main.Option
    -> Data.Set.Internal.Set Main.Option
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
873e19b460bf1f3a851b86a24373e336
  $sintersection ::
    Data.Set.Internal.Set Main.Option
    -> Data.Set.Internal.Set Main.Option
    -> Data.Set.Internal.Set Main.Option
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [~] -}
77de30839d3e9392450d68db81a29c66
  $tc'A :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   693283182868825203##
                   17013768436588654685##
                   Main.$trModule
                   Main.$tc'A2
                   0#
                   Main.$tc'A1) -}
eb12d7fc09f840b0b2b5274e71d94084
  $tc'A1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
0937be9027af050425c2bbef6d0cd4bf
  $tc'A2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'A3) -}
a3fdd975f39250cfaa91ef289869d0d3
  $tc'A3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'A"#) -}
3d4d888aed051736f9baff3f588c65a8
  $tc'B :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5204529440822741764##
                   15433236706311297883##
                   Main.$trModule
                   Main.$tc'B1
                   0#
                   Main.$tc'A1) -}
10b517a60ab1695cbdf3aa7657f9cfa2
  $tc'B1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'B2) -}
28f7a54356ef5a96c151065401f985bd
  $tc'B2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'B"#) -}
4e55ffcc13bc1ad74f5601d4b07cbd21
  $tc'C :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10502984155413422402##
                   772885320322164953##
                   Main.$trModule
                   Main.$tc'C1
                   0#
                   Main.$tc'A1) -}
df6ccf690947f4024c7ea05b9217331d
  $tc'C1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'C2) -}
4011cbdf03a08acee3c74e1375c09fdf
  $tc'C2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'C"#) -}
f674108646f651ae437dd7a1215cd87a
  $tc'D :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11200506575140875495##
                   5756650805477444705##
                   Main.$trModule
                   Main.$tc'D1
                   0#
                   Main.$tc'A1) -}
852d630ca737cc52a221ec3379633125
  $tc'D1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'D2) -}
d723e916755c60d356cbccf3eba0e834
  $tc'D2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'D"#) -}
07438549e237137df8cded7d8cc46ebc
  $tc'Sol :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7813639466710882042##
                   11463007721675120674##
                   Main.$trModule
                   Main.$tc'Sol2
                   0#
                   Main.$tc'Sol1) -}
141caa005939d119318407303addea79
  $tc'Sol1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b4855974569d04a435de8c83d970f7e9
  $tc'Sol2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Sol3) -}
d29c14d6fc6347365405cf5315e2c19a
  $tc'Sol3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Sol"#) -}
cd8b3076f4582864e0c13f921212016b
  $tc'Var :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   941528533574368362##
                   2414828796846326931##
                   Main.$trModule
                   Main.$tc'Var2
                   0#
                   Main.$tc'Var1) -}
b13de3d25c8096b32cef08d2b01c396c
  $tc'Var1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d794eb41864ee6912ef8d9f366e17b3f
  $tc'Var2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Var3) -}
9d50a35c0b55e825dba255a913f262c0
  $tc'Var3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Var"#) -}
c723da21320dc7eab9a1d2bb14971fc7
  $tcOption :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6830047086661459213##
                   7292556350065071816##
                   Main.$trModule
                   Main.$tcOption1
                   0#
                   GHC.Types.krep$*) -}
283ead1510f3ad81f5492c3794eb7132
  $tcOption1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcOption2) -}
11111a2ff8ba40c66cf00af2fe338462
  $tcOption2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Option"#) -}
628d9d78d85a1b74b880d8037949a28a
  $tcTerm :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1834001997265462586##
                   13403085435679011199##
                   Main.$trModule
                   Main.$tcTerm1
                   0#
                   GHC.Types.krep$*) -}
b4273b07364d9be6bd906ab99d8b0f2a
  $tcTerm1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcTerm2) -}
21503caf1522df9df1434ae119d6376f
  $tcTerm2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Term"#) -}
be86c9d078d3acbf19ba91fe74a24273
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
b09d86f2c49dd5176b544d8d13ddb6c5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
23b03bd7d075a00f5ad1ee10e6add7b8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
bb2123bad4e2d9c530a12b7e82302052
  $w$ccomplement ::
    Rcheck.Solver.Addr
    -> Rcheck.Solver.Addr
    -> (# Rcheck.Solver.LState Main.Term
          -> [((), Rcheck.Solver.LState Main.Term)] #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
3b7dbedc3c67552275f00ba17a40f48c
  $w$cshowsPrec :: Main.Option -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Main.Option) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Main.A -> GHC.Base.++ @ GHC.Types.Char Main.$fShowOption7 w1
                   Main.B -> GHC.Base.++ @ GHC.Types.Char Main.$fShowOption5 w1
                   Main.C -> GHC.Base.++ @ GHC.Types.Char Main.$fShowOption3 w1
                   Main.D -> GHC.Base.++ @ GHC.Types.Char Main.$fShowOption1 w1 }) -}
bb2123bad4e2d9c530a12b7e82302052
  $w$cshowsPrec1 :: GHC.Prim.Int# -> Main.Term -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: Main.Term) ->
                 case w of wild {
                   Main.Var b1
                   -> case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             Main.$fShowTerm4
                             (case b1 of ww2 { GHC.Types.I# ww3 ->
                              case GHC.Show.$wshowSignedInt 11# ww3 x of ww4 { (#,#) ww5 ww6 ->
                              GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Main.$fShowTerm4
                                (case b1 of ww2 { GHC.Types.I# ww3 ->
                                 case GHC.Show.$wshowSignedInt
                                        11#
                                        ww3
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.$fShow(,)2
                                           x) of ww4 { (#,#) ww5 ww6 ->
                                 GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }
                   Main.Sol b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = Data.Set.Internal.$w$cshowsPrec
                            @ Main.Option
                            Main.$fShowOption
                            11#
                            b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Main.$fShowTerm2 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Main.$fShowTerm2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
3b7dbedc3c67552275f00ba17a40f48c
  $w$ctoEnum :: GHC.Prim.Int# -> Main.Option
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.>=# ww 0# of lwild {
                   DEFAULT -> Main.$wlvl ww
                   1#
                   -> case GHC.Prim.<=# ww 3# of lwild1 {
                        DEFAULT -> Main.$wlvl ww
                        1# -> GHC.Prim.tagToEnum# @ Main.Option ww } }) -}
bb2123bad4e2d9c530a12b7e82302052
  $w$cunify ::
    Main.Term
    -> Main.Term
    -> (# Rcheck.Solver.LState Main.Term
          -> [((), Rcheck.Solver.LState Main.Term)] #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
b3a0d3f39dd41dbc0ba2fcec6638654d
  $wgo3 ::
    GHC.Prim.Int#
    -> Data.Set.Internal.Set Main.Option
    -> [Main.Option]
    -> Data.Set.Internal.Set Main.Option
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
3b7dbedc3c67552275f00ba17a40f48c
  $wlvl :: GHC.Prim.Int# -> Main.Option
  {- Arity: 1, Strictness: <B,U>x, Inline: [0] -}
bb2123bad4e2d9c530a12b7e82302052
  $wpruneSol ::
    Main.Term
    -> (# Rcheck.Solver.LState Main.Term
          -> [((GHC.Types.Int,
                GHC.Base.Maybe (Data.Set.Internal.Set Main.Option)),
               Rcheck.Solver.LState Main.Term)] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
ccf95d09d8b66d700c62f68eb0667b9b
  (==>) ::
    Main.Option
    -> Rcheck.Logic.Cond Main.Term
    -> Main.Term
    -> Rcheck.Logic.Cond Main.Term
  {- Arity: 3, Strictness: <L,U><L,U><L,U>m5,
     Unfolding: InlineRule (3, True, False)
                (\ (a :: Main.Option)
                   (b :: Rcheck.Logic.Cond Main.Term)
                   (c :: Main.Term) ->
                 Rcheck.Logic.And
                   @ Main.Term
                   (Rcheck.Logic.Unify
                      @ Main.Term
                      Main.$fUnifyTerm
                      c
                      (Main.Sol
                         (Main.$sfromList
                            (GHC.Types.: @ Main.Option a (GHC.Types.[] @ Main.Option)))))
                   b) -}
3b7dbedc3c67552275f00ba17a40f48c
  data Option = A | B | C | D
bb2123bad4e2d9c530a12b7e82302052
  data Term
    = Var GHC.Types.Int | Sol (Data.Set.Internal.Set Main.Option)
0f99b3698baa15e1cee697424b047aab
  and ::
    Rcheck.Logic.Cond a -> Rcheck.Logic.Cond a -> Rcheck.Logic.Cond a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m5,
     Unfolding: InlineRule (0, True, True) Rcheck.Logic.And -}
a25929275c5eaf4088723a236ccc904f
  emptyAllocator :: Rcheck.Solver.Allocator a
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ a ->
                 Rcheck.Solver.Allocator
                   @ a
                   (Data.Map.Internal.Tip @ GHC.Types.Int @ a)
                   Main.emptyAllocator1) -}
540cc5e9f29705b7236196c07349294d
  emptyAllocator1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
4c2f233b0dc2853e2896258208efc8b4
  emptyLState :: Rcheck.Solver.LState a
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ a ->
                 Rcheck.Solver.LState
                   @ a
                   (Main.emptyAllocator @ a)
                   (GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int))
                   (GHC.Types.[]
                      @ (Rcheck.BrMonad.Br (Rcheck.Solver.LState a) GHC.Types.Bool))) -}
94dacb856e30371c22a2e6460f297115
  eq :: Rcheck.Solver.Unify a => a -> a -> Rcheck.Logic.Cond a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m1,
     Unfolding: InlineRule (0, True, True) Rcheck.Logic.Unify -}
3202d9839b71d61bd86e57853ce854af
  for ::
    Main.Term
    -> (Main.Term -> Rcheck.Logic.Cond Main.Term)
    -> Rcheck.BrMonad.Br (Rcheck.Solver.LState Main.Term) ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Main.Term)
                   (f :: Main.Term -> Rcheck.Logic.Cond Main.Term) ->
                 Rcheck.Logic.solve @ Main.Term (f a)) -}
4309cf3c8b3e0a9bcfd33a05bc98a8fc
  format :: [GHC.Base.String] -> [[Main.Term]] -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.format1
                  `cast`
                (<[GHC.Base.String]>_R
                 ->_R <[[Main.Term]]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
4b4627305a38c77b92bda7679fa7c413
  format1 ::
    [GHC.Base.String]
    -> [[Main.Term]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U>,
     Unfolding: (\ (names :: [GHC.Base.String])
                   (xs :: [[Main.Term]])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 letrec {
                   go23 :: [[Main.Term]]
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [[Main.Term]])
                       (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case ds of wild {
                       [] -> (# eta1, GHC.Tuple.() #)
                       : y ys
                       -> case GHC.IO.Handle.Text.hPutStr2
                                 GHC.IO.Handle.FD.stdout
                                 Main.format3
                                 GHC.Types.True
                                 eta1 of ds1 { (#,#) ipv ipv1 ->
                          let {
                            exit :: GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                              <join 1> {- Arity: 1, Strictness: <S,U> -}
                            = \ (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              go23 ys eta2
                          } in
                          let {
                            exit1 :: GHC.Prim.State# GHC.Prim.RealWorld
                                     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                              <join 1> {- Arity: 1, Strictness: <S,U> -}
                            = \ (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              go23 ys eta2
                          } in
                          letrec {
                            go24 :: [[GHC.Types.Char]]
                                    -> [Main.Term]
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                              <join 3> {- Arity: 3, Strictness: <S,1*U><L,1*U><S,U> -}
                            = \ (ds2 :: [[GHC.Types.Char]])
                                (_ys :: [Main.Term])
                                (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                              case ds2 of wild1 {
                                [] -> exit eta2
                                : ipv2 ipv3
                                -> case _ys of wild2 {
                                     [] -> exit1 eta2
                                     : ipv4 ipv5
                                     -> case GHC.IO.Handle.Text.hPutStr2
                                               GHC.IO.Handle.FD.stdout
                                               (GHC.Base.++_$s++
                                                  @ GHC.Types.Char
                                                  (GHC.CString.unpackAppendCString#
                                                     Main.format2
                                                     (case ipv4 of wild3 {
                                                        Main.Var b1
                                                        -> GHC.CString.unpackAppendCString#
                                                             Main.$fShowTerm4
                                                             (case b1 of ww2 { GHC.Types.I# ww3 ->
                                                              case GHC.Show.$wshowSignedInt
                                                                     11#
                                                                     ww3
                                                                     (GHC.Types.[]
                                                                        @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                                              GHC.Types.:
                                                                @ GHC.Types.Char
                                                                ww5
                                                                ww6 } })
                                                        Main.Sol b1
                                                        -> GHC.Base.++
                                                             @ GHC.Types.Char
                                                             Main.$fShowTerm2
                                                             (GHC.Types.:
                                                                @ GHC.Types.Char
                                                                GHC.Show.$fShow(,)4
                                                                (GHC.Base.++
                                                                   @ GHC.Types.Char
                                                                   Data.Set.Internal.$fShowSet1
                                                                   (case Data.Set.Internal.$fDataSet_go
                                                                           @ Main.Option
                                                                           (GHC.Types.[]
                                                                              @ Main.Option)
                                                                           b1 of wild4 {
                                                                      [] -> Main.$fShowTerm5
                                                                      : x xs1
                                                                      -> GHC.Types.:
                                                                           @ GHC.Types.Char
                                                                           GHC.Show.showList__3
                                                                           (Main.$w$cshowsPrec
                                                                              x
                                                                              (Main.$fShowTerm_showl
                                                                                 xs1)) }))) }))
                                                  GHC.Show.$fShow(,)3
                                                  (GHC.Show.showLitString ipv2 GHC.Show.$fShow[]1))
                                               GHC.Types.True
                                               eta2 of ds3 { (#,#) ipv6 ipv7 ->
                                        go24 ipv3 ipv5 ipv6 } } }
                          } in
                          go24 names y ipv } }
                 } in
                 go23 xs eta) -}
aeeef4ce31a457fbbf45856010975976
  format2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" : "#) -}
20bd6c42aa0f74ddb3b77140780f6a22
  format3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.format4) -}
29dfcb108ec75c91a3559ee4c931d46b
  format4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("===="#) -}
4c58f982e26a8a8176ee0cce00bf9a4d
  main :: GHC.Types.IO ()
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
929bae3d76c4dac372c07fe1c05fabec
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Unfolding: (Main.format1 Main.main7 Main.main2) -}
1f070a63f9ddd4aa629cffaaae3a98c0
  main2 :: [[Main.Term]]
  {- Unfolding: (case Main.main4 of wild { Rcheck.BrMonad.Br ds ->
                 Data.OldList.nubBy
                   @ [Main.Term]
                   Main.main3
                   (GHC.Base.map
                      @ ([Main.Term], Rcheck.Solver.LState Main.Term)
                      @ [Main.Term]
                      (Data.Tuple.fst @ [Main.Term] @ (Rcheck.Solver.LState Main.Term))
                      (Main.main_go (ds (Main.emptyLState @ Main.Term)))) }) -}
48e83b97bb4d7b3d9d487a2efdde6c0c
  main3 :: [Main.Term] -> [Main.Term] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (GHC.Classes.$fEq[]_$c== @ Main.Term Main.$fEqTerm) -}
016e0bd574e04ae2430b8a0c09561d7b
  main4 ::
    Rcheck.BrMonad.Br (Rcheck.Solver.LState Main.Term) Main.Term
  {- Unfolding: (case Rcheck.Solver.$wstore
                        @ Main.Term
                        Main.$fReferenceTerm
                        Main.main5 of ww { Unit# ww1 ->
                 Rcheck.BrMonad.Br
                   @ (Rcheck.Solver.LState Main.Term)
                   @ Main.Term
                   ww1 }) -}
7d53c730f2900c3af09e80928205a506
  main5 :: Main.Term
  {- Strictness: m2, Unfolding: (Main.Sol Main.main6) -}
fb99b21af0d941d2987ad0abc3f3a538
  main6 :: Data.Set.Internal.Set Main.Option
  {- Unfolding: (Main.$sfromList Main.total) -}
988b32233a0d6ce68d71bb97b919712e
  main7 :: [GHC.Base.String]
  {- Unfolding: (Main.main_go1 Main.main8) -}
185a67370aa0c4c6b710d767b639711d
  main8 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
fdcb5fa9013cb96f8a7549fc127080e5
  main9 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
809d99a56c7d5c0f18191bb173167013
  main_go ::
    [(Main.Term, Rcheck.Solver.LState Main.Term)]
    -> [([Main.Term], Rcheck.Solver.LState Main.Term)]
  {- Arity: 1, Strictness: <S,1*U> -}
0566ef4d8940546d45864ef72a758569
  main_go1 :: GHC.Integer.Type.Integer -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U> -}
36df01ff664f363bc39b4cd5c1280a72
  neq :: Rcheck.Solver.Unify a => a -> a -> Rcheck.Logic.Cond a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ a ($dUnify :: Rcheck.Solver.Unify a) (a1 :: a) (b :: a) ->
                 Rcheck.Logic.Not @ a (Rcheck.Logic.Unify @ a $dUnify a1 b)) -}
6180deae72367a79b0abb49550e678ef
  not :: Rcheck.Logic.Cond a -> Rcheck.Logic.Cond a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (0, True, True) Rcheck.Logic.Not -}
180effd2819f9a14e456e5a22ca2dc31
  nub :: [[Main.Term]] -> [[Main.Term]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: [[Main.Term]]) ->
                 Data.OldList.nubBy @ [Main.Term] Main.main3 eta) -}
1e7f8afebe329b85f7e39d477f87bd6e
  or ::
    Rcheck.Logic.Cond a -> Rcheck.Logic.Cond a -> Rcheck.Logic.Cond a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (0, True, True) Rcheck.Logic.Or -}
fe4eded7312971e0db575d740c430c1b
  pruneSol ::
    Main.Term
    -> Rcheck.BrMonad.Br
         (Rcheck.Solver.LState Main.Term)
         (GHC.Types.Int, GHC.Base.Maybe (Data.Set.Internal.Set Main.Option))
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Main.Term) ->
                 case Main.$wpruneSol w of ww { Unit# ww1 ->
                 Rcheck.BrMonad.Br
                   @ (Rcheck.Solver.LState Main.Term)
                   @ (GHC.Types.Int,
                      GHC.Base.Maybe (Data.Set.Internal.Set Main.Option))
                   ww1 }) -}
1c56a7c88f052372d8440a331515bfde
  sol :: [Main.Option] -> Main.Term
  {- Arity: 1, Strictness: <L,1*U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [Main.Option]) -> Main.Sol (Main.$sfromList x)) -}
ae1d1abb3e1d2ca529fa1a3e4bc9f0b6
  test ::
    Rcheck.BrMonad.Br (Rcheck.Solver.LState Main.Term) [Main.Term]
  {- Strictness: m,
     Unfolding: (Rcheck.BrMonad.Br
                   @ (Rcheck.Solver.LState Main.Term)
                   @ [Main.Term]
                   Main.test1) -}
5c062db984d351dc0ca54adb24f31bc4
  test1 ::
    Rcheck.Solver.LState Main.Term
    -> [([Main.Term], Rcheck.Solver.LState Main.Term)]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Rcheck.Solver.LState Main.Term) ->
                 case Main.main4 of wild { Rcheck.BrMonad.Br ds ->
                 Main.main_go (ds s1) }) -}
20de74c85c36074ab9bfb742884db5c2
  toSol ::
    Main.Term
    -> Rcheck.BrMonad.Br (Rcheck.Solver.LState Main.Term) Main.Option
  {- Arity: 1, Strictness: <L,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Main.Term) ->
                 let {
                   w1 :: Rcheck.BrMonad.Br
                           (Rcheck.Solver.LState Main.Term)
                           (GHC.Types.Int, GHC.Base.Maybe (Data.Set.Internal.Set Main.Option))
                   = case Main.$wpruneSol w of ww { Unit# ww1 ->
                     Rcheck.BrMonad.Br
                       @ (Rcheck.Solver.LState Main.Term)
                       @ (GHC.Types.Int,
                          GHC.Base.Maybe (Data.Set.Internal.Set Main.Option))
                       ww1 }
                 } in
                 Rcheck.BrMonad.Br
                   @ (Rcheck.Solver.LState Main.Term)
                   @ Main.Option
                   (\ (s1 :: Rcheck.Solver.LState Main.Term) ->
                    case w1 of wild { Rcheck.BrMonad.Br ds ->
                    Main.toSol_go (ds s1) })) -}
a30a7b660f23d979c1ccd9895c5cc088
  toSol_go ::
    [((GHC.Types.Int,
       GHC.Base.Maybe (Data.Set.Internal.Set Main.Option)),
      Rcheck.Solver.LState Main.Term)]
    -> [(Main.Option, Rcheck.Solver.LState Main.Term)]
  {- Arity: 1, Strictness: <S,1*U> -}
f39129134e1bd24d666c44b535dcbd36
  total :: [Main.Option]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Main.Option Main.A Main.total1) -}
6ab3416cc60fb00dcc7b226f4a153887
  total1 :: [Main.Option]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Main.Option Main.B Main.total2) -}
b78752c9c3b3dadd3375915778ecc086
  total2 :: [Main.Option]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Main.Option Main.C Main.total3) -}
0c400e2e851cf3ceedc647c68bf2e1a4
  total3 :: [Main.Option]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Main.Option
                   Main.D
                   (GHC.Types.[] @ Main.Option)) -}
c0565d3d62d328979862a02a65a60965
  (|-) ::
    Rcheck.Logic.Cond a -> Rcheck.Logic.Cond a -> Rcheck.Logic.Cond a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m6,
     Unfolding: InlineRule (0, True, True) Rcheck.Logic.Imply -}
7578ea2c5edbf4a471b5904d9250bf2c
  (|||) ::
    (Main.Term -> Rcheck.Logic.Cond Main.Term)
    -> (Main.Term -> Rcheck.Logic.Cond Main.Term)
    -> Main.Term
    -> Rcheck.Logic.Cond Main.Term
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U)><L,U>m4,
     Unfolding: InlineRule (3, True, False)
                (\ (a :: Main.Term -> Rcheck.Logic.Cond Main.Term)
                   (b :: Main.Term -> Rcheck.Logic.Cond Main.Term)
                   (t :: Main.Term) ->
                 Rcheck.Logic.Or @ Main.Term (a t) (b t)) -}
instance [safe] Rcheck.Solver.Complement [Main.Term]
  = Main.$fComplementTerm
instance [safe] GHC.Enum.Enum [Main.Option] = Main.$fEnumOption
instance [safe] Rcheck.Solver.EnumSet [Main.Term]
  = Main.$fEnumSetTerm
instance [safe] GHC.Classes.Eq [Main.Option] = Main.$fEqOption
instance [safe] GHC.Classes.Eq [Main.Term] = Main.$fEqTerm
instance [safe] GHC.Classes.Ord [Main.Option] = Main.$fOrdOption
instance [safe] Rcheck.Solver.Reference [Main.Term]
  = Main.$fReferenceTerm
instance [safe] GHC.Show.Show [Main.Option] = Main.$fShowOption
instance [safe] GHC.Show.Show [Main.Term] = Main.$fShowTerm
instance [safe] Rcheck.Solver.Unify [Main.Term] = Main.$fUnifyTerm
"SPEC/Main fromList @ Option" forall ($dOrd :: GHC.Classes.Ord
                                                 Main.Option)
  Data.Set.Internal.fromList @ Main.Option $dOrd = Main.$sfromList
"SPEC/Main intersection @ Option" forall ($dOrd :: GHC.Classes.Ord
                                                     Main.Option)
  Data.Set.Internal.intersection @ Main.Option $dOrd
  = Main.$sintersection
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

